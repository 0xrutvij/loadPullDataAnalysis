# Filename:  mdfParser_v2.py
# Date:      04/17/2021
# Author:    Rutvij Shah, Adhiraj Sen
# Email:     rutvij.shah@utdallas.edu
# Version:   2.0
# Copyright: 2021, All Rights Reserved
#
# Written for the senior design project, Load Pull Analysis Team.
#
# Description:
#   Parse load pull data from .mdf files
#   Current version accounts for different numbers of variables
#   but the names are hard coded, changing boolean conditions
#   within the elif statement checking 'VAR<>', can account for
#   other named variables.
#   Future versions should implement this as well as the spliting of
#   the gamma tuple to discrete gamma value columns.
#   Another addition can be reading in values of S1 through S3 in the header
#   and the value of Z_0.
#
#
#   Refer to the this documentation for information on mdf files generated by AWR Cadence
#   - https://awrcorp.com/download/faq/english/docs/users_guide/data_file_formats.html

import os, math, string, pathlib;
import pandas as pd
import numpy as np



    
# Read/Parse MDF function
def parseMdf(fileLoc: str) -> pd.DataFrame:
    """Parses an MDF file generated by AWR Cadence (Microwave Office)

    Parameters
    ----------
    fileLoc : str
        The file location of the MDF file, if the file is in the same directory,
        then only the filename is required.
    
    Returns
    -------
    DataFrame
        The MDF file converted into a pandas DataFrame
    """

    with open(fileLoc , 'r') as inFile:
        mdfFile = inFile.readlines()
        numGammaSweeps = 0
        blockSize = 4
        blocksRead = 0
        dictList = []

        i = 0
        while i < len(mdfFile):
            if mdfFile[i].startswith('!'):
                i+=1
                continue
            elif mdfFile[i].startswith('BEGIN'):
                l1 = mdfFile[i].split()
                if l1[1].startswith('HEADER'):
                    i += 3
                    continue
                elif l1[1].startswith('ABWAVES'):
                    i += 5
                    continue
            elif mdfFile[i].startswith('VAR<>'):
                l1 = mdfFile[i].split()
                if l1[1].startswith('iPower'):
                    i+=1
                    continue
                elif l1[1].startswith('iGamma'):
                    i+=1
                    numGammaSweeps+=1
                    blockSize+=1
                    continue

            if mdfFile[i][0].isdigit():
                blocksRead = 0
                power = int(mdfFile[i])
                i+=1
                gammaX = tuple(int(mdfFile[i+k]) for k in range(numGammaSweeps))
                i+=numGammaSweeps
                for j in range (1, 4):
                    lineList = mdfFile[i].split()
                    lineList = list(map(float, lineList))
                    harm = lineList[0]
                    a1 = complex(lineList[1], lineList[2])
                    b1 = complex(lineList[3], lineList[4])
                    a2 = complex(lineList[5], lineList[6])
                    b2 = complex(lineList[7], lineList[8])
                    if j == 1:
                        v1, i1, v2, i2 = (lineList[x] for x in range(9, 13))
                    else:
                        v1, i1, v2, i2 = tuple(np.nan for i in range(4))
                    dictList.append({'gammaTuple': gammaX,
                    'power': power,
                    'harmonic': int(harm),
                    'a1': a1,
                    'b1': b1,
                    'a2': a2,
                    'b2': b2,
                    'V1': v1,
                    'I1': i1,
                    'V2': v2,
                    'I2': i2
                    })
                    i+=1
                blocksRead+=1
            i+=1
            
        df = pd.DataFrame.from_dict(dictList)
        
        return df

#Additional Calculations function
def calculateMetrics(df: pd.DataFrame) -> pd.DataFrame:
    """Calculates load pull data from observed data.
    Adds columns for Pin, Pout, Gain, PAE, drain efficiency,
    and Load Gamma (r: real, jx: imaginary).

    Parameters
    ----------
    df : DataFrame
        The pandas data frame generated by the parseMdf function.
    
    Returns
    -------
    DataFrame
        A DataFrame with the columns of calculated metrics added to the DF.
    """
	
    df['Pin'] = 0.5*((abs(df['a1']**2) - abs(df['b1'])**2))
    df['Pout'] = 0.5*((abs(df['b2']**2) - abs(df['a2'])**2)) #dBm
    df['Gain'] = df['Pout']/df['Pin'] 
    df['Pdc1'] = df['V1']*df['I1']
    df['Pdc2'] = df['V2']*df['I2']
    df['PAE'] = ((df['Pout']-df['Pin'])/df['Pdc2'])*100
    df['drainEff'] = (df['Pout']/df['Pdc2'])*100
    df['Load Gamma'] = df['a2']/df['b2']

    # separate real and imaginary components of Load Gamma into r and jx columns
    column_a1 = df["Load Gamma"]
    r = []
    jx = []
    for index, value in column_a1.iteritems():
        r.append(value.real)
        jx.append(value.imag)
    df['r'] = r
    df['jx'] = jx 

    return df

# convert columns to correct units
def unitConversions(df: pd.DataFrame) -> pd.DataFrame:
    """Converts Gain to dB, and Pout/Pin to dBm

    Parameters
    ----------
    df : DataFrame
        The pandas data frame generated by the calculatedMetrics function.
    
    Returns
    -------
    DataFrame
        A DataFrame with the units of Gain, Pin and Pout converted in place.
    """
    to_dB = lambda x: 10 * math.log10(abs(x))
    to_dBm = lambda x: 10 * math.log10(abs(x)*1000)

    df['Gain'] = df['Gain'].apply(to_dB)
    df['Pout'] = df['Pout'].apply(to_dBm)
    df['Pin'] = df['Pin'].apply(to_dBm)

    return df

#Export file Function
def exportFiles(df: pd.DataFrame, filepath: str) -> None:
    """Exports the DataFrame to .csv and .pkl format for later use.

    Parameters
    ----------
    df : DataFrame
        The pandas data frame generated by the calculatedMetrics or unitConversions function.

    filepath : str
        The name of the file to be saved + the location. path/filename, if the file is to be
        saved in the same directory, just provide filename.
    
    Returns
    -------
    None
    """
    # export as pickle
    df.to_pickle(filepath + ".pkl")

    # export to csv
    df.to_csv(filepath + ".csv")
      



    
        

    
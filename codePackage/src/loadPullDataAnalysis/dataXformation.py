from __future__ import annotations
import numpy as np
import pandas as pd


def dfFromPkl(filename: str) -> pd.DataFrame:
    '''Reading the pickle file and initialiazing it as a dataframe (df).

    :param filename: The pickle file generated from the parser
    :type filename: str
    :returns: The dataframe that is unpickled from the pickled file (generated by the parser)
    :rtype: pandas.DataFrame
    '''
    df = pd.read_pickle(filename)
    df.set_index(keys=['gammaTuple'], drop=False,inplace=True)
    return df

def filterColVal(
    df: pd.DataFrame,
    colName: str,
    value: float,
    filType: str = None
) -> pd.DataFrame:
    '''Filter a column of the DF using the value and operation provided.

    :param df: The original df
    :type df: pandas.DataFrame
    :param colName: Name of the column to be filtered
    :type colName: str
    :param value: Value to compare against
    :type value: str
    :param fillType: The string  value indicating what operation should be used to filter the column values   ( >= is geq, > gt, < lt, <= leq, == eq)
    :type fillType: pandas.DataFrame
    :returns: Filtered DF.
    :rtype: pandas.DataFrame
    '''
    if filType == 'geq':
        return df[df[colName] >= value]
    elif filType == 'gt':
        return df[df[colName] > value]
    elif filType == 'lt':
        return df[df[colName] < value]
    elif filType == 'leq':
        return df[df[colName] <= value]
    else:
        return df[df[colName] == value]

def dfWithCols(df: pd.DataFrame, ls: list[str]) -> pd.DataFrame:
    '''Return the dataframe retaining only certain columns.

    :param df: DataFrame whose columns need to be subset.
    :type df: pandas.DataFrame
    :param ls: List of columns to retain.
    :type ls: list[str]
    :returns: Copy of the updated df with columns
    :rtype: pandas.DataFrame
    '''
    return df[ls].copy()


def calcGComp(df: pd.DataFrame) -> pd.DataFrame:
    '''Finds the maximum value for Gain, then use it to calculate gComp.

    :param df: DataFrame with the Gain column
    :type df: pandas.DataFrame

    :returns: The updated dataframe with gComp added as a column
    :rtype: pandas.DataFrame
    '''
    df = df.copy()
    maxGain = df['Gain'].max()
    df['gComp'] = df['Gain'] - maxGain
    return df

def filterOnCompressionThreshold(df: pd.DataFrame, compVal: float) -> pd.DataFrame:
    '''Filters a dataframe based on a given compression value.

    :param df: DataFrame with the gComp column
    :type df: pandas.DataFrame
    :returns: The updated dataframe with points only beyond the compression value.
    :rtype: pandas.DataFrame
    '''
    x = df['Pout'].to_numpy().transpose()
    f = df['gComp'].to_numpy().transpose()
    l = np.array([-compVal]*len(x))
    idx = np.argwhere(np.diff(np.sign(f - l))).flatten()
    intersections = x[idx]
    if len(intersections) != 0:
        df = df[df['Pout'] > intersections[0]]

    #return df, x, f
    return df

def splitGammaTuple(df: pd.DataFrame) -> pd.DataFrame:
    '''Split the Gamma Tuple into its component vals, one column for each member.

    :param df:Dataframe with the gammaTuple as one of its cols.
    :type df: pandas.DataFrame
    :returns: The dataframe with split gamma values.
    :rtype: pandas.DataFrame
    '''
    numGammas = len(df['gammaTuple'][0])
    splitGammasList = []

    for i in range(numGammas):
        splitGammasList.append([])

    for i, row in df.iterrows():
        gT = row['gammaTuple']
        for j in range(numGammas):
            splitGammasList[j].append(gT[j])

    name = 'gamma'
    for i in range(numGammas):
        colName = name + str(i+1)
        df[colName] = splitGammasList[i]

    return df

def splitOnUniqueGammaTuples(df: pd.DataFrame) -> list[pd.DataFrame]:
    '''Creates a list of DFs each one having a unique GammaTuple value and
    all the power indices for each.

    :param df: DataFrame with gammaTuple as one of its cols.
    :type df: pandas.DataFrame
    :returns: A list of DataFrames with unique Gamma vals separated.
    :rtype: list[pandas.DataFrame]
    '''
    uniqGammas=df['gammaTuple'].unique().tolist()

    listGamDf = []

    for gam in uniqGammas:
        gamDf = df.loc[df.gammaTuple==gam]
        gamDf.index = range(len(gamDf))
        listGamDf.append(gamDf)

    return listGamDf

def pickVariable(sliceVar: str, df: pd.DataFrame) -> dict[str, float]:
    '''Returns the information for a variable in the DF. This is used to information
        potential valid slicing values.

    :param selVar: The name of the column to be sliced.
    :type selVer: str
    :param df: DataFrame containing that column.
    :type df: pandas.DataFrame
    :returns: A dictionary that contains maxVal, minVal, stepSize, defaultVal
    :rtype: dict[str, float]
    '''
    varInfoDict = {}
    varInfoDict['maxVal'] = df[sliceVar].max()
    varInfoDict['minVal'] = df[sliceVar].min()
    varInfoDict['stepSize'] = max((varInfoDict['maxVal']-varInfoDict['minVal'])/100, 0.1)
    varInfoDict['defaultVal'] = df[sliceVar].median()

    return varInfoDict


def interpolatedSlice(
    dfList: list[pd.DataFrame],
    sliceVar: str,
    sliceVal: float
) -> tuple[list[str], pd.DataFrame]:
    '''Slices a column of the DFs at a particular value and returns a DF with
        values for other columns interpolated at that value.

    :param dfList: A list of DataFrames with unique gamma values.
    :type dfList: list[pd.DataFrame]
    :param sliceVar: Column of the df that will be sliced
    :type sliceVar: str
    :param sliceVal: The numeric value to slice at
    :type sliceVal: float
    :returns: selList, a list of potential plotting variables
    :rtype: list[str]
    :returns: dfOfLoadsAtVarX the interpolated DF.
    :rtype: pandas.DataFrame
    '''

    listGamDfC = dfList.copy()
    CONST_VAL = sliceVal
    selectedVariable = sliceVar
    dfOfLoadsAtVarX = pd.DataFrame()

    cols = listGamDfC[-1].columns.to_list()
    cols.remove(selectedVariable)
    cols.remove('gammaTuple')

    for i,gamDf in enumerate(listGamDfC):
        calcDict = {}
        selVarList = gamDf[[selectedVariable]].to_numpy().transpose().tolist()[0]
        for col in cols:
            colVals = gamDf[[col]].to_numpy().transpose().tolist()[0]
            calcVal = np.interp(CONST_VAL, selVarList, colVals)
            #calcVal = barycentric_interpolate(selVarList, colVals, FIXED_POUT)
            calcDict[col] = round(float(calcVal),6)
        calcDict[selectedVariable] = CONST_VAL
        calcDict['gammaTuple'] = gamDf['gammaTuple'].iloc[0]
        dfOfLoadsAtVarX = dfOfLoadsAtVarX.append(calcDict, ignore_index=True)
        listGamDfC[i] = gamDf.append(calcDict, ignore_index=True).sort_values(by=['power'],ignore_index=True)

    dfOfLoadsAtVarX = dfOfLoadsAtVarX.sort_values(by=['gammaTuple'],ignore_index=True)
    colList = dfList[0].columns
    selList = list(set(colList) - {sliceVar, 'r', 'jx'})

    return selList, dfOfLoadsAtVarX
